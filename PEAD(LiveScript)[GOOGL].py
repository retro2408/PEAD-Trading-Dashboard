
# -*- coding: utf-8 -*-
"""RegModel-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-dZAS3UFrL7EpwpeU69c8SeTjetzhb8
"""


import pandas as pd
import sys 
sys.path.insert(0,"")

"""
Commented out code to utilize Alpha Vantage API to get historical earnigns, balance sheet and income statement 
data.  

Used the API only once and created csv's from which we retrieve the data.
"""

# # Define the symbol for which you want to retrieve financial data
# symbol = 'GOOGL'  # You can replace 'AMD' with any other ticker symbol

# # Base URL for Alpha Vantage API
# base_url = "https://www.alphavantage.co/query"

# # Parameters for income statement
# income_params = {
#     "function": "INCOME_STATEMENT",
#     "symbol": symbol,
#     "apikey": api_key
# }

# # Parameters for balance sheet
# balance_params = {
#     "function": "BALANCE_SHEET",
#     "symbol": symbol,
#     "apikey": api_key
# }

# # Parameters for Earnings data
# earnings_params = {
#     "function": "EARNINGS",
#     "symbol": symbol,
#     "apikey": api_key
# }

# # Parameters for Cash Flow data
# cashflow_params = {
#     "function": "CASH_FLOW",
#     "symbol": symbol,
#     "apikey": api_key
# }

# # Get quarterly income statement data
# income_response = requests.get(base_url, params=income_params)
# income_data = income_response.json()

# # Extract quarterly income statement data
# if "quarterlyReports" in income_data:
#     income_df = pd.DataFrame(income_data["quarterlyReports"])
#     print("Income Statement (Quarterly):")
#     print(income_df.head())
# else:
#     print("Error fetching income statement data:", income_data)

# # Get quarterly balance sheet data
# balance_response = requests.get(base_url, params=balance_params)
# balance_data = balance_response.json()

# # Extract quarterly balance sheet data
# if "quarterlyReports" in balance_data:
#     balance_df = pd.DataFrame(balance_data["quarterlyReports"])
#     print("Balance Sheet (Quarterly):")
#     print(balance_df.head())
# else:
#     print("Error fetching balance sheet data:", balance_data)

# # # Get quarterly earnings report data
# # earnings_response = requests.get(base_url, params=earnings_params)
# # earnings_data = earnings_response.json()

# # # Extract quarterly balance sheet data
# # if "quarterlyReports" in earnings_data:
# #     earnings_df = pd.DataFrame(earnings_data["quarterlyReports"])
# #     print("Earnings Report (Quarterly):")
# #     print(earnings_df.head())
# # else:
# #     print("Error fetching earnings sheet data:", earnings_data)

# # Get quarterly cash flow sheet data
# cashflow_response = requests.get(base_url, params=cashflow_params)
# cashflow_data = cashflow_response.json()

# # Extract cash flow sheet data
# if "quarterlyReports" in cashflow_data:
#     cashflow_df = pd.DataFrame(cashflow_data["quarterlyReports"])
#     print("Cash Flow Report (Quarterly):")
#     print(cashflow_df.head())
# else:
#     print("Error fetching balance sheet data:", cashflow_data)

# income_csv = income_df.to_csv('income_GOOGL.csv')
# balance_csv = balance_df.to_csv('balance_GOOGL.csv')
# cashflow_csv = cashflow_df.to_csv('cashflow_GOOGL.csv')


import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from statsmodels.stats.outliers_influence import variance_inflation_factor
from statsmodels.api import OLS, add_constant

#READ GENERATED DATA FROM CSV
income_df = pd.read_csv('MarketProfile/income_GOOGL.csv')
balance_df = pd.read_csv('MarketProfile/balance_GOOGL.csv')
cashflow_df = pd.read_csv('MarketProfile/cashflow_GOOGL.csv')

#DROP COLUMNS NOT REQUIRED
cashflow_df = cashflow_df.drop(columns=['Unnamed: 0'])
income_df = income_df.drop(columns=['Unnamed: 0'])
balance_df = balance_df.drop(columns=['Unnamed: 0'])
income_df = income_df.drop(columns=['reportedCurrency'])
balance_df = balance_df.drop(columns=['reportedCurrency'])
cashflow_df = cashflow_df.drop(columns=['reportedCurrency'])
income_df = income_df.drop(columns=['fiscalDateEnding'])
balance_df = balance_df.drop(columns=['fiscalDateEnding'])
cashflow_df = cashflow_df.drop(columns=['fiscalDateEnding'])

# Checking column information after dropping
# cashflow_df.info(verbose=True)
# balance_df.info(verbose=True)
# income_df.info(verbose=True)

#FIND MISSING % STATS and DROP according to cutoff parameter

missing_prcnt_cashflow = cashflow_df.isnull().mean().sort_values(ascending=False)
missing_prcnt_income = income_df.isnull().mean().sort_values(ascending=False)
missing_prcnt_balance = balance_df.isnull().mean().sort_values(ascending=False)

cutoff = 0.10

dropped_list_cashflow = sorted(list(missing_prcnt_cashflow[missing_prcnt_cashflow > cutoff].index))
dropped_list_balance = sorted(list(missing_prcnt_balance[missing_prcnt_balance > cutoff].index))
dropped_list_income = sorted(list(missing_prcnt_income[missing_prcnt_income > cutoff].index))

cashflow_df.drop(labels=dropped_list_cashflow, axis=1, inplace=True)
balance_df.drop(labels=dropped_list_balance, axis=1, inplace=True)
income_df.drop(labels=dropped_list_income, axis=1, inplace=True)

balance_df = balance_df.ffill()
income_df = income_df.ffill()
cashflow_df = cashflow_df.ffill()

# Converting all columns to int64 for ease of calculations
for col in income_df.columns:
    income_df[col] = income_df[col].astype(int)
for col in balance_df.columns:
    balance_df[col] = balance_df[col].astype(int)
for col in cashflow_df.columns:
    cashflow_df[col] = cashflow_df[col].astype(int)

# Basic Dataframe checking
# income_df.info(verbose=True)
# cashflow_df.info(verbose=True)
# balance_df.shape

# Merge df1 and df2 on indexes, then merge the result with df3
merged_df = pd.merge(pd.merge(balance_df, income_df, left_index=True, right_index=True, how="inner"), cashflow_df, left_index=True, right_index=True, how="inner")

# Find columns with '_x' and '_y' suffixes and drop duplicates
for col in merged_df.columns:
    if '_x' in col:
        original_col_name = col.replace('_x', '')
        if original_col_name + '_y' in merged_df.columns:
            # Drop the '_y' version of the duplicated column
            merged_df.drop(columns=[original_col_name + '_y'], inplace=True)
        # Rename the '_x' column to remove the suffix
        merged_df.rename(columns={col: original_col_name}, inplace=True)

# merged_df.info(verbose=True)

# Commented out IPython magic to ensure Python compatibility.
import yfinance as yf
import pandas as pd
from datetime import datetime
import matplotlib.pyplot as plt
# %matplotlib inline

tickerlist = ['GOOGL']
ticker_objlist = []
ticker_dfs = {}
for item in tickerlist :
      ticker_objlist.append(yf.Ticker(item))
      ticker_dfs[item] = (ticker_objlist[tickerlist.index(item)].get_earnings_dates(64))
      today = pd.Timestamp.now(tz='America/New_York').normalize()
      ticker_dfs[item] = ticker_dfs[item][ticker_dfs[item].index <= today]
eps_df = ticker_dfs['GOOGL'].reset_index()
finance_df = pd.merge(merged_df, eps_df, left_index=True, right_index=True, how="inner")

""" Created a correlation heatmap considering all financial statement components and exported to exel."""
# with pd.ExcelWriter('correlation_matrix.xlsx') as writer:
#     finance_df.corr().style.background_gradient(cmap='coolwarm').to_excel(writer, sheet_name='CorrelationMatrix', engine='openpyxl')

""" Using surprise as the filter for financial statement components"""

target_column = 'Surprise(%)'
# Calculate correlations of all columns with the target column
correlations = finance_df.corr()[target_column].drop(target_column)  # Exclude correlation of target with itself
# Sort by absolute correlation to find the highest correlations
sorted_correlations = correlations.abs().sort_values(ascending=False)
# Keep labels with highest correlation
top_labels = sorted_correlations.index.tolist()  # List of columns with highest correlation with target
# All components with a threshold correlation more than 0.20 are not filtered out.
threshold = 0.20
top_labels = sorted_correlations[sorted_correlations > threshold].index.tolist()
# Create a reduced DataFrame with the target column and the selected labels
reduced_data = finance_df[[target_column] + top_labels + ['Reported EPS']]
#data might be collinear but can be further removed

"""Shifting the EPS one quarter before, so the previous quarter data can be used to predict the next quarter's
data. """

reduced_data['Shift_Reported_EPS'] = reduced_data['Reported EPS'].shift(1)
newest_first_quarter = reduced_data.iloc[[0]]
newest_first_quarter_X = newest_first_quarter.drop(columns=['Reported EPS', 'Shift_Reported_EPS'])
reduced_data = reduced_data.drop(index=0)
reduced_data = reduced_data.drop(columns=['Reported EPS'])

""" Performing the multi-variate regression below"""

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
Y = reduced_data['Shift_Reported_EPS']
X = reduced_data.drop(columns=['Shift_Reported_EPS'])
sk_X_train, sk_X_test, sk_Y_train, sk_Y_test = train_test_split(X, Y, test_size=0.3, random_state=99)
regressor = LinearRegression()
regressor.fit(sk_X_train, sk_Y_train)
sk_intercept_carprice = regressor.intercept_
sk_engsize_coeffs = regressor.coef_
sk_ssr_carprice = np.sum((sk_Y_train-regressor.predict(sk_X_train))**2)
pd.Series(sk_engsize_coeffs, index=sk_X_train.columns)
print('The intercept value is {:.1f}'.format(sk_intercept_carprice))
print('The sum of square residuals is {:.1f}'.format(sk_ssr_carprice))

sk_test_predictions = regressor.predict(sk_X_test)
import matplotlib.pyplot as plot
plot.scatter(sk_test_predictions, sk_Y_test)

newest_quarter_prediction = regressor.predict(newest_first_quarter_X)
print(newest_quarter_prediction)  #USE REGRESSION MODEL TO PREDICT THE NEXT QUARTERS EARNINGS

# %%
import datetime
from datetime import date
import sys 
sys.path.insert(0,"/Users/architsharma/Desktop/twsapi_macunix/IBJts/source/pythonclient/")
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract
from ibapi.order import Order
from ibapi.execution import *
import time
import threading
import random 

# %%
#reported eps to be fetched through a script for a ticker, how? lets try selenium for google first 

# Stockvec = ['MSFT', 'GOOGL' , 'AMD' , 'V' , 'SYK']
stock = 'GOOGL'
Estimate = newest_quarter_prediction  #integrating the regression output to the estimate 

"""Start of live component for Earnings PDF parsing and Sending Signal to Broker"""
import schedule
from datetime import datetime
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
import requests
import pdfplumber

#GOOGL SCRIPT
# Set target quarter and initialize driver outside the function for efficiency
targetQ = 'Q3'
service = Service(ChromeDriverManager().install())
driver = webdriver.Chrome(service=service)

# Flag to track if the PDF has been found and processed
pdf_found = False

def check_for_pdf():
    try:
        print("Checking for PDF at", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        url = "https://abc.xyz/investor/earnings/"
        driver.get(url)
    
    
        year_title = driver.find_element(By.CLASS_NAME, 'EarningsCards-title')
        
        if year_title.text == '2024': 
            earnings_container = year_title.find_element(By.XPATH, './following-sibling::*[contains(@class, "EarningsCards-items")]')
            earnings_items = earnings_container.find_elements(By.CLASS_NAME, "EarningsCards-items-item")
            
            for item in earnings_items:
                quarter_label = item.find_element(By.CLASS_NAME, 'EarningsCard-label').text
                if quarter_label == targetQ:
                    release = item.find_element(By.CSS_SELECTOR, 'a.EarningsCard-earningsRelease-link')
                    pdf_url = release.get_attribute("href")
                    
                    # Download the PDF file
                    response = requests.get(pdf_url)
                    pdf_path = "earnings_release_q2.pdf"
                    with open(pdf_path, 'wb') as pdf_file:
                        pdf_file.write(response.content)
                    print("PDF downloaded successfully at", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
                    
                    # Parse the PDF
                    with pdfplumber.open(pdf_path) as pdf:
                        tables = pdf.pages[0].extract_tables()
                        epsvec = tables[-1][-1][0].split()[-1]
                        global epsreported
                        epsreported = epsvec
                        print('EPS VEC' , epsvec)

                    pdf_found = True
                    # Close the driver as the PDF is found and processed
                    driver.quit()
                    
                    return schedule.CancelJob  # Stop further scheduling once PDF is found
        else:
            print("2024 earnings data not available yet.")
    except Exception as e:
        print("Error checking for PDF:", e)
    

def start_checking():
    # Schedule the check_for_pdf function every 10 seconds starting at 4:00 p.m.
    schedule.every().day.at("16:00").do(lambda: schedule.every(10).seconds.do(check_for_pdf))

    # Run the scheduler
    while True:
        schedule.run_pending()
        time.sleep(1)

        if check_for_pdf():
            print("PDF found and EPS extracted. Scheduler stopped.")
            break

# print("PDF found and EPS extracted. Scheduler stopped.")
# Start the checking routine
start_checking()

''' Signal Generation Methods to open and close the position '''
def signal(stock,vec,estimate) :      #regression 
      surprise = float(vec)/estimate   
      if surprise >= 1.22  :     
            signal = "BUY"
      elif surprise <= 1.04 :   
            signal = "SELL" 
      else : 
            signal = "NONE"
      print(surprise)
      return signal 


def flipsignal(signal) : 
    if signal == 'BUY' : 
        signal = 'SELL' 
    elif signal == 'SELL' : 
         signal = 'BUY' 
    else : 
         signal = signal 
    return signal 
     
# %%
trigger = 0 #Variable defined to hold the price 

from decimal import Decimal
from ibapi.client import *
from ibapi.wrapper import *
from ibapi.tag_value import *
from datetime import datetime
import time 
import sys 
import threading
import random  

port = 7497

#USE BROKER TO GET LIVE PRICE DATA AND SET IT ON GLOBAL VARIABLE NAMED TRIGGER 
class TestAppLive(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)

    def nextValidId(self, orderId: OrderId):

        mycontract = Contract()
        mycontract.symbol = stock
        mycontract.secType = "STK"
        mycontract.exchange = "SMART"
        mycontract.currency = "USD"


        self.reqRealTimeBars(
            reqId=123,
            contract=mycontract,
            barSize=5,
            whatToShow="TRADES",
            useRTH=False,
            realTimeBarsOptions=[],
        )

    def realtimeBar(
        self,
        reqId: TickerId,
        time: int,
        open_: float,
        high: float,
        low: float,
        close: float,
        volume: Decimal,
        wap: Decimal,
        count: int,
    ):
        print(
            datetime.now().strftime("%H:%M:%S.%f")[:-3],
            "realtimeBar.",
            f"reqId:{reqId}",
            f"time:{time}",
            f"open_:{open_}",
            f"high:{high}",
            f"low:{low}",
            f"close:{close}",
            f"volume:{volume}",
            f"wap:{wap}",
            f"count:{count}",
        )
        global trigger 
        trigger = close #STORE PRICE ON VARIABLE 
        self.disconnect()
    


    def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
         print(f"openOrder. orderId: {orderId}, contract: {contract}, order: {order}")

    def error(self, reqId: TickerId, errorCode: int, errorString: str, advancedOrderRejectJson=""):
        print(reqId, errorCode, errorString, advancedOrderRejectJson)






app = TestAppLive()
app.connect("127.0.0.1", port,random.randint(1,10000))
app.run()

import json 
out_dic = {
    'Signal' : signal(stock,epsreported,Estimate),
    'EPS Reported' : epsreported ,
    'EPS Estimate' : list(Estimate)}
with open("output.json", "w") as json_file:
    json.dump(out_dic, json_file, indent=4)

#
capital = 10000  #SET CAPITAL TO TRADE WITH 
quantity = capital//trigger   # DECIDE QUANTITY 
print(quantity)

# %%
from ibapi.client import *
from ibapi.wrapper import *
import time
port=7497

class TestApp(EClient, EWrapper):
    def __init__(self):
        EClient.__init__(self, self)

    def nextValidId(self, orderId):
            super().nextValidId(orderId)
            self.nextValidOrderId = orderId
            
            print("NextValidId:", orderId)

    def nextValidId(self, orderId: OrderId):

        mycontract = Contract()
        mycontract.symbol = "GOOGL"
        mycontract.exchange = "SMART"
        mycontract.secType = "STK"
        mycontract.currency = 'USD'
        print(f"ACTION : {signal(stock,epsreported,Estimate)},triggerPRICE : {trigger}")
        myorder = Order()
        myorder.action = signal(stock,epsreported,Estimate) 
        myorder.tif = "GTC"
        myorder.orderType = "LMT"
        myorder.lmtPrice = float(trigger) - 0.25 if signal(stock,epsreported,Estimate) == "SELL" else float(trigger)+0.25  #to ensure a fill  # need to set based on buy order or sell 
        myorder.outsideRth = True
        myorder.orderId = orderId 
        myorder.totalQuantity = quantity
    

        self.placeOrder(myorder.orderId, mycontract, myorder)  #SEND FIRST ORDER
        time.sleep(3) #WAIT TILL THE HOLDING PERIOD 
        appLive = TestAppLive()
        appLive.connect("127.0.0.1", port,random.randint(1,10000))
        appLive.run()
        print(f"ACTION : {flipsignal(signal(stock,epsreported,Estimate))},triggerPRICE : {trigger}")
        myorderclose = Order() 
        myorderclose.action = flipsignal(signal(stock,epsreported,Estimate))  #FLIP EXISTING SIGNAL TO CLOSE POSITION
        myorderclose.tif = "GTC" 
        myorderclose.orderType = "LMT"
        myorderclose.lmtPrice = float(trigger) - 0.5 if flipsignal(signal(stock,epsreported,Estimate)) == "SELL" else float(trigger) + 0.5 
        myorderclose.outsideRth = True 
        myorderclose.totalQuantity = quantity 
        myorderclose.orderId = myorder.orderId + 15
        self.placeOrder(myorderclose.orderId, mycontract, myorderclose)  #CLOSE POSITION
        self.disconnect()

    def openOrder(self, orderId: OrderId, contract: Contract, order: Order, orderState: OrderState):
        print(f"openOrder. orderId: {orderId}, contract: {contract}, order: {order}") 
        print(f"Maintenance Margin: {orderState.maintMarginAfter}, {orderState.maintMarginBefore}, {orderState.maintMarginChange}")
        print(f"Initial Margin: {orderState.initMarginAfter}, {orderState.initMarginBefore}, {orderState.initMarginChange}")


    def orderStatus(self, orderId: OrderId, status: str, filled: Decimal, remaining: Decimal, avgFillPrice: float, permId: int, parentId: int, lastFillPrice: float, clientId: int, whyHeld: str, mktCapPrice: float):
        print(f"orderId: {orderId}, status: {status}, filled: {filled}, remaining: {remaining}, avgFillPrice: {avgFillPrice}, permId: {permId}, parentId: {parentId}, lastFillPrice: {lastFillPrice}, clientId: {clientId}, whyHeld: {whyHeld}, mktCapPrice: {mktCapPrice}")


    def execDetails(self, reqId: int, contract: Contract, execution: Execution):
        print(f"reqId: {reqId}, contract: {contract}, execution: {execution}")

    def error(self, reqId: TickerId, errorCode: int, errorString: str, advancedOrderRejectJson=""):
        print("Error", reqId, errorCode, errorString, advancedOrderRejectJson)

app = TestApp()
app.connect("127.0.0.1", port, random.randint(1,10000))
app.run()



# %%



